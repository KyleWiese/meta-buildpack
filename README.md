# Meta-Buildpack

This is a Cloud Foundry buildpack that enables decomposition of buildpacks into "real" buildpacks
(the ones that create a droplet from the submitted source), and "decorators" (buildpacks that
inject other smarts into the droplet generated by the first buildpack).

## Objective

The main objective of this buildpack is to reduce the NxM problem of having buildpacks for each
programming language, and add-on features that support multiple languages. Specifically, I wanted
to add Spring Cloud Service support to as many non-Java languages as possible, and prior to
creating the meta-buildpack, I had to fork and modify the buildpack for each supported language
in order to do that. The same issue applies to things like Application Performance Monitoring
solutions that support multiple languages. If we separate the (N) language buildpacks
from the (M) feature add-on buildpacks, we have reduced the problem to N+M instead.

## How it works

The meta-buildpack should be pushed to the top of the list of installed buildpacks in Cloud Foundry
(the provided upload script places it there for you). It is thus always invoked before any other
buildpack, and is able to claim the build regardless of what language the submitted source is in.
The meta-buildpack will then proceed to invoke the "real" buildpacks just as they would have been
without the meta-buildpack present. The language buildpack will `detect` and claim the build, and
its `compile` step will produce a droplet like it normally would.

After the real buildpack runs, control passes back to the meta-buildpack, and it will then proceed
to invoke "decorator" buildpacks. Decorators are installed like any other buildpack (by convention
at the bottom of the list of buildpacks), but their `detect` scripts always return false, and they
instead are identified by having a `decorate` script that returns true if the decorator applies.
If any decorator returns true, its compile step is invoked to modify the droplet.

Unlike language buildpacks, decorators are not mutually exclusive. The meta-buildpack will invoke
all decorators that return true from their `decorate` scripts, so any number of them can be applied
to a single droplet.

## How to install the meta-buildpack

To install the meta-buildpack at the top of the buildpack list, simply run the provided upload
script. You must be logged in to Cloud Foundry with a role that allows buildpack installations.

```
git clone https://github.com/guidowb/meta-buildpack.git
cd meta-buildpack
./upload
```

## <a name="decorators"></a>How to write a decorator

A decorator is installed and invoked just like any other buildpack, with a couple of significant
differences.

1. To prevent the decorator from being invoked as a buildpack, its `bin/detect` script should
always return false. Here's a sample:

   ```
   #!/usr/bin/env bash
   # bin/detect <build-dir>
   # We are a decorator, not a buildpack, so we always decline to build
   exit 1
   ```

2. Instead, the real detection for a decorator is done by the `bin/decorate` script. The presence
of this script is what enables the meta-buildpack to identify decorators:

   ```
   #!/usr/bin/env bash
   # bin/decorate <build-dir>
   
   BIN_DIR=$(cd $(dirname $0); pwd)
   ROOT_DIR=$(dirname $BIN_DIR)
   BUILD_DIR=$1
   
   # Determine if the app meets the criteria to be decorated by this decorator
   # Exit 0 if you want the decorator to run, non-zero if not
   ```

   Remember that before the `decorate` script is invoked, the real buildpack will already have
   been run, so the entire droplet is present in `BUILD_DIR` for you to inspect. So is the
   application environment (including things like `VCAP_SERVICES` to determine what services
   are bound to the application).

3. If the `bin/decorate` script returns true (zero), the meta-buildpack will run the `bin/compile`
script. The environment for that script looks exactly like it would for a real buildpack, *except*
the real buildpack has already run, so the entire droplet is already present in `BUILD_DIR`.

*REMEMBER* that any number of decorators may be invoked for the same droplet. While decorators
are invoked in the order in which they are in the buildpack list, it is best to make no assumptions
about the order in which yours will be invoked.

## Available decorators

- [Spring Cloud Config](https://github.com/guidowb/spring-config-decorator)

#!/bin/bash
# bin/compile <build-dir> <cache-dir> <env-dir>
set -o pipefail

# Set a flag for our detect script, so that when we re-invoke the
# buildpack runner, our buildpack will pass, and the actual buildpack
# will end up being invoked
touch ~/.decorator-buildpack-compiling

# Now recursively re-invoke the staging process to invoke buildpacks the normal way
echo >&2 '-----> [decorator-buildpack] Invoking standard buildpacks'
ruby /var/vcap/packages/dea_next/buildpacks/bin/run /var/vcap/data/dea_next/staging/*/plugin_config
result=$?

# Remove our flag
rm ~/.decorator-buildpack-compiling

# If the standard buildpack execution failed, propagate that failure here
if [ "$result" -ne 0 ]
then
	exit "$result"
fi

# The standard build process succeeded. Now run the decorators...
echo >&2 '-----> [decorator-buildpack] Evaluating decorators'
cat /var/vcap/data/dea_next/staging/*/plugin_config |
grep '^- \"\?/var/vcap/data/dea_next/admin_buildpacks/' |
sed "s/^- //" | sed 's/^\"//' | sed 's/\"$//' |
while read buildpack
do
	if [ -f $buildpack/bin/decorate ]
	then
		framework=`$buildpack/bin/decorate`
		claimed=$?
		if [ "$claimed" -eq 0 ]
		then
			echo >&2 '-----> [decorator-buildpack] Invoking decorator' "$framework" 
			$buildpack/bin/compile
			result=$?
			if [ "$result" -ne 0 ]
			then
				echo >&2 '-----> [decorator-buildpack] Decorator' "$framework" 'failed'
				exit "$result"
			fi
		fi
	fi
done

echo >&2 '-----> [decorator-buildpack] Done' 
